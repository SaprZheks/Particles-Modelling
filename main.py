# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\modelling.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = r".\.venv\Lib\site-packages\PyQt5\Qt5\plugins\platforms"
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, pyqtSignal,QThread
from ui import Ui_MainWindow
import numpy as np

from itertools import combinations

class Particle():
    def __init__(self, x, y, v_x=0.0, v_y=0.0, m = 1.0, sigma=1.0, epsilon=1.0, diam=10.0, color="red", type="ordinary", draw_obj=None):
        self.x = x
        self.y = y
        self.v_x = v_x
        self.v_y = v_y
        self.m = m
        self.sigma = sigma
        self.epsilon = epsilon
        self.diam = diam
        self.color = color
        self.type = type
        self.draw_obj = draw_obj

        self.F_x = 0.0
        self.F_y = 0.0
        



class UI(Ui_MainWindow):
    def __init__(self):
        self.run_flag = 0
        self.particles = []
        self.scale = 1.0
        self.sim_speed = 1.
        self.FPS = 60
        self.dt = 1/self.FPS
        self.v_edge_x = 0.0
        self.solver_thread_run_flag = True
        self.edge_speed = 10.

    def generate_particles(self):
        
        ret = []
        
        # Делаем матрицу частиц k на n 
        n = 20
        k = 15
        k_2 = 0

        # Левая верхняя граница
        x_0 = 100
        y_0 = 100

        m_0 = 15        # Вода
        sigma_0 = 40    # Вода
        epsilon_0 = 700 # Вода

        m_2 = 15        # Железо
        sigma_2 = 40    # Железо
        epsilon_2 = 1200 # Железо

        m_1 = 15        # Мыло
        sigma_1 = 20    # Мыло
        epsilon_1 = 200 # Мыло

        d_0 = self.get_r_0(sigma_0)
        d_2 = self.get_r_0(sigma_2)
        edge_width = int(10 * max(sigma_0, sigma_2)/d_2)
        self.v_0 = 15
        

        # Генерация левой железной границы
        for i in range(edge_width):
            for j in range(k + 2* k_2 + edge_width):
                ret.append([x_0 + i*d_0,    # x
                            y_0 + (-edge_width/2 - k_2 +j)*d_0 ,# y
                            0.,             # v_x
                            0.,             # v_y
                            m_2,            # m
                            sigma_2,        # sigma
                            epsilon_2,      # epsilon
                            d_0/2,          # diam
                            "freezed edge", # type
                            "grey"])         # color

        # Генерация пленки
        for i in range(n):
            for j in range(k):
                ret.append([x_0 + (edge_width+i)*d_0,    # x
                            y_0 + j*d_0,    # y
                            np.random.random()*self.v_0,             # v_x
                            np.random.random()*self.v_0,             # v_y
                            m_0,            # m
                            sigma_0,        # sigma
                            epsilon_0,      # epsilon
                            d_0/2,          # diam
                            "ordinary", # type
                            "green"])       # color
            
        for i in range(n):
            for j in range(k_2):
                ret.append([x_0 + (edge_width+i)*d_0,    # x
                            y_0 - (1+j)*d_0,    # y
                            np.random.random()*self.v_0,             # v_x
                            np.random.random()*self.v_0,             # v_y
                            m_1,            # m
                            sigma_1,        # sigma
                            epsilon_1,      # epsilon
                            d_0/2,          # diam
                            "ordinary", # type
                            "#f5b642"])       # color
                ret.append([x_0 + (edge_width+i)*d_0,    # x
                            y_0 + (k+j)*d_0,    # y
                            np.random.random()*self.v_0,             # v_x
                            np.random.random()*self.v_0,             # v_y
                            m_1,            # m
                            sigma_1,        # sigma
                            epsilon_1,      # epsilon
                            d_0/2,          # diam
                            "ordinary", # type
                            "#f5b642"])       # color
                    
        # Генерация правой железной границы
        for i in range(edge_width):
            for j in range(k + 2 * k_2 + edge_width):
                ret.append([x_0 + (edge_width + n + i)*d_0,    # x
                            y_0 + (-edge_width/2 - k_2 +j)*d_0 ,# y
                            0.,             # v_x
                            0.,             # v_y
                            m_2,            # m
                            sigma_2,        # sigma
                            epsilon_2,      # epsilon
                            d_0/2,          # diam
                            "movable edge", # type
                            "red"])         # color
                    


            '''
            # x,    y,   v_x, v_y,  m, sigma, epsilon, diam,      type,     color
        ret = [[300., 100., 0.,  0., 15., 20.,    300.,   2*20*2**(1/6),  "ordinary", "green"],
            [300., 150., 0.,  0., 15., 20.,    300.,   2*20*2**(1/6),  "ordinary", "green"],
            [250., 150., 0.,  0., 15., 20.,    300.,   2*20*2**(1/6),  "ordinary", "green"],
            [250., 100., 0.,  0., 15., 20.,    300.,   2*20*2**(1/6),  "ordinary", "green"],
            [200., 100., 0.,  0., 15., 200.,    300.,   100,  "ordinary", "green"],
            [50.,  70.,  10,   0., 15., 200.,    300.,    30., "movable edge", "red"],
            [50.,  150.,  0,   0., 15., 200.,    300.,    30., "freezed edge", "blue"]]
        '''
        return ret

    def camera_init(self):
        self.camera_x = self.Simulation.width()//2
        self.camera_y = self.Simulation.height()//2

    def slider_init(self):
        self.horizontalSlider_speed.setMinimum(-100)
        self.horizontalSlider_speed.setMaximum(100)
        self.horizontalSlider_speed.setValue(0)

    def init(self):
        self.set_handlers()
        self.camera_init()
        self.slider_init()
        self.particles_init()
        self.threads_init()

  
    def show(self):
        w = self.Simulation.width()
        h = self.Simulation.height()
        cam_x = self.camera_x
        cam_y = self.camera_y
        scale = self.scale
        for particle in self.particles:
            x = int((particle.x - cam_x)*scale + w/2) 
            y = int((particle.y - cam_y)*scale + h/2)
            if not(x >= 2147483647 or x <= -2147483647 or y >= 2147483647 or y <= -2147483647):
                diam = int(particle.diam * scale)
                particle.draw_obj.setGeometry(x-diam//2, y-diam//2, diam, diam)
                particle.draw_obj.setStyleSheet("""
                background-color: %s;
                border-radius: %dpx;
            """ % (particle.color, diam // 2))
                particle.draw_obj.show()
            else:
                diam = 0
                particle.draw_obj.setGeometry(-100, -100, diam, diam)
                particle.draw_obj.show()

        
        self.PushButton_zoom_plus.raise_()
        self.PushButton_zoom_minus.raise_()
        self.PushButton_up.raise_()
        self.PushButton_down.raise_()
        self.PushButton_left.raise_()
        self.PushButton_right.raise_()

    
    def get_r_0(self, sigma):
        return sigma * 2**(1/6)
    

    def update_particles(self, particles):
        for i in range(np.shape(particles)[0]):
            self.particles[i].x = particles[i, 0]
            self.particles[i].y = particles[i, 1]
        self.solver_thread_run_flag = True


    def update(self):
        if self.thread.isRunning() == False and self.solver_thread_run_flag == True:
            self.solver_thread_run_flag = False
            self.thread.start()
        self.show()

    def threads_init(self):
        self.solver = Solver(self.particles, self.sim_speed, self.dt)
        self.thread = QThread()
        self.solver.moveToThread(self.thread)
        self.thread.started.connect(self.solver.solve)
        self.solver.finishSignal.connect(self.thread.quit)
        self.solver.finishSignal.connect(self.update_particles)
        self.thread.start()
    
    def set_handlers(self):
        self.pushButton_run.clicked.connect(self.run_sim)
        self.PushButton_zoom_plus.clicked.connect(self.zoom_plus)
        self.PushButton_zoom_minus.clicked.connect(self.zoom_minus)
        self.PushButton_up.clicked.connect(self.up)
        self.PushButton_down.clicked.connect(self.down)
        self.PushButton_left.clicked.connect(self.left)
        self.PushButton_right.clicked.connect(self.right)
        self.pushButton_edge_left.clicked.connect(self.edge_left)
        self.pushButton_edge_stop.clicked.connect(self.edge_stop)
        self.pushButton_edge_right.clicked.connect(self.edge_right)
        self.horizontalSlider_speed.valueChanged.connect(self.speed_slider)


    def edge_left(self):
        self.solver.v_edge_x_init = -self.edge_speed
    
    def edge_stop(self):
        self.solver.v_edge_x_init = 0.0

    def edge_right(self):
        self.solver.v_edge_x_init = self.edge_speed

    def speed_slider(self):
        self.sim_speed = 20.0**(self.horizontalSlider_speed.value()/100)
        self.solver.sim_speed_init = self.sim_speed

    def zoom_plus(self):
        self.scale += 0.1

    def zoom_minus(self):
        self.scale -= 0.1

    def up(self):
        self.camera_y -= int(20 / self.scale)

    def down(self):
        self.camera_y += int(20 / self.scale)
    
    def left(self):
        self.camera_x -= int(20 / self.scale)

    def right(self):
        self.camera_x += int(20 / self.scale)

    def run_sim(self):
        if self.run_flag == 0:
            self.run_flag = 1
            self.pushButton_run.setText("Stop")
        else:
            self.run_flag = 0
            self.pushButton_run.setText("Run")
        self.solver.run_flag_init = self.run_flag
            
    def add_particle(self, x, y, v_x, v_y, m, sigma, epsilon, diam, type, color):
        draw_obj = QtWidgets.QLabel(self.Simulation)
        draw_obj.setGeometry(x-diam//2, y-diam//2, diam, diam)
        draw_obj.setStyleSheet("""
            background-color: %s;
            border-radius: %dpx;
        """ % (color, diam // 2))
        draw_obj.show()
        self.particles.append(Particle(x-diam//2, y-diam//2, v_x, v_y, m, sigma, epsilon, diam, color, type, draw_obj))
    
    def particles_init(self):
        particles = self.generate_particles()
        for particle in particles:
            self.add_particle(particle[0], particle[1], particle[2], particle[3],  particle[4],  particle[5], particle[6], particle[7], particle[8], particle[9])


class Solver(QObject):
    finishSignal = pyqtSignal(np.ndarray)
    def __init__(self, particles, sim_speed, dt):
        super(Solver, self).__init__()
        self.max_force = 1000
        self.x = np.array([])
        self.y = np.array([])
        self.sigma_1_2 = np.array([])
        self.epsilon_sqrt = np.array([])
        self.m = np.array([])
        self.v_x = np.array([])
        self.v_y = np.array([])
        self.F_x = np.array([])
        self.F_y = np.array([])
        self.type = np.array([])
        # 0 - ordinary
        # 1 - movable edge
        # 2 - freezed edge
        for particle in particles:
            self.x = np.append(self.x, particle.x)
            self.y = np.append(self.y, particle.y)
            self.sigma_1_2 = np.append(self.sigma_1_2, particle.sigma/2)
            self.epsilon_sqrt = np.append(self.epsilon_sqrt, np.sqrt(particle.epsilon))
            self.m = np.append(self.m, particle.m)
            self.v_x = np.append(self.v_x, particle.v_x)
            self.v_y = np.append(self.v_y, particle.v_y)
            if particle.type == "ordinary":
                self.type = np.append(self.type, 0)
            elif particle.type == "movable edge":
                self.type = np.append(self.type, 1)
            elif particle.type == "freezed edge":
                self.type = np.append(self.type, 2)
            else:
                self.type = np.append(self.type, -1)
            self.F_x = np.append(self.F_x, 0)
            self.F_y = np.append(self.F_y, 0)

        self.n = np.shape(self.x)[0]
        self.sim_speed_init = sim_speed
        self.dt = dt
        self.run_flag_init = 0
        self.v_edge_x_init = 0

        self.n = len(self.x)
        self.SIGMA = np.tile(np.array([self.sigma_1_2]).T, (1, self.n)) + np.tile(self.sigma_1_2, (self.n, 1))
        self.EPSILON = np.dot(np.array([self.epsilon_sqrt]).T, np.array([self.epsilon_sqrt]))
        

    def solve(self):
        self.run_flag = self.run_flag_init
        self.sim_speed = self.sim_speed_init
        self.v_edge_x = self.v_edge_x_init
        if self.run_flag:
            self.update_forces_matrix() # Обновить силы
            self.update_vel()    # Обновить скорости
            self.update_pos()    # Обновить положения
        
        for i in range(self.n):
            if i != 0:
                particles = np.append(particles, [[self.x[i], self.y[i]]], axis=0)
            else:
                particles = np.array([[self.x[i], self.y[i]]])
        self.finishSignal.emit(particles)

    def update_forces_matrix(self):
        n = self.n
        R_x = np.tile(self.x, (n, 1)) - np.tile(np.array([self.x]).T, (1, n))
        R_y = np.tile(self.y, (n, 1)) - np.tile(np.array([self.y]).T, (1, n))
        R = np.sqrt(np.pow(R_x, 2) + np.pow(R_y, 2))
        RATIO = self.SIGMA/R
        RATIO_1 = np.pow(RATIO, 13) / self.SIGMA
        RATIO_2 = np.pow(RATIO, 7) / self.SIGMA
        F = 24 * self.EPSILON * (2 * RATIO_1 - RATIO_2)

        
        R_x_n = R_x/R
        R_y_n = R_y/R

        F_x = np.nan_to_num(F * R_x_n)
        F_y = np.nan_to_num(F * R_y_n)

        self.F_x = np.sum(F_x, axis=0)
        self.F_y = np.sum(F_y, axis=0)

    def update_vel(self):
        for i in range(self.n):
            if self.type[i] == 0:
                self.v_x[i] += self.F_x[i] / self.m[i] * self.dt * self.sim_speed
                self.v_y[i] += self.F_y[i] / self.m[i] * self.dt * self.sim_speed
            elif self.type[i] == 1:
                self.v_x[i] = self.v_edge_x * self.sim_speed
                self.v_y[i] = 0 * self.sim_speed
            elif self.type[i] == 2:
                self.v_x[i] = 0 * self.sim_speed
                self.v_y[i] = 0 * self.sim_speed

    def update_pos(self):
        for i in range(self.n):
            self.x[i] += self.v_x[i] * self.dt * self.sim_speed
            self.y[i] += self.v_y[i] * self.dt * self.sim_speed

    def force(self, r, sigma_1, epsilon_1, sigma_2, epsilon_2):
        sigma = (sigma_1 + sigma_2)/2
        epsilon = np.sqrt(epsilon_1 * epsilon_2)
        ratio = sigma/r
        ratio_13 = np.power(ratio, 13)
        ratio_7 = np.power(ratio, 7)
        force = 24 * epsilon * (2 *  ratio_13 -  ratio_7) # Сила отталкивания
        return 10

    
    def update_forces(self):
        for i in range(self.n):
            self.F_x[i] = 0.0
            self.F_y[i] = 0.0
        
        for i, j in combinations(range(self.n),2):
            x_1 = self.x[i]
            y_1 = self.y[i]
            sigma_1 =self.sigma[i]
            epsilon_1 = self.epsilon[i]

            x_2 = self.x[j]
            y_2 = self.y[j]
            sigma_2 = self.sigma[j]
            epsilon_2 = self.epsilon[j]
                    
            r_x = x_2 - x_1
            r_y = y_2 - y_1
            r = np.sqrt(r_x**2 + r_y**2)
            if r > 0.01:
                r_x /= r
                r_y /= r
                force = self.force(r, sigma_1, epsilon_1, sigma_2, epsilon_2)
            else:
                r_x = 1
                r_y = 1
                force = 0.0

            force_1_x = r_x * force
            force_1_y = r_y * force

            self.F_x[i] -= force_1_x
            self.F_y[i] -= force_1_y
            self.F_x[j] += force_1_x
            self.F_y[j] += force_1_y

if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = UI()
    ui.setupUi(MainWindow)
    ui.init()
    
    timer = QtCore.QTimer()
    timer.timeout.connect(ui.update)   # будет вызывать ui.handler() каждые interval мс
    timer.start(1/ui.FPS)              # ~60 вызовов в секунду
    ui._timer = timer                  # важно: держать ссылку на timer, чтобы GC не собрал его
    MainWindow.show()
    sys.exit(app.exec_())
